<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryStateV2">
    <option name="chatSessions" value="{&quot;6ec96812-a621-4cb3-b8f8-a7a9ef61bb09&quot;:{&quot;id&quot;:&quot;6ec96812-a621-4cb3-b8f8-a7a9ef61bb09&quot;,&quot;name&quot;:&quot;Inizio dello swap delle card in BikeScreen.kt al contatto iniziale tra le card&quot;,&quot;timestamp&quot;:1766074322344,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Voglio sapere una cosa: su BikeScreen.kt c\u0027è una proprietà che mi permetta di gestire l\u0027inizio dello swap delle card quando le card si \&quot;sfiorano\&quot; ancora prima di sovrapporsi, quindi quando la prima card si è mossa solo dello spacing tra le card (se la card ha un padding di zero ed uno spacer esterno)?&quot;}],&quot;context&quot;:[{&quot;file_path&quot;:&quot;app/src/main/java/com/moxmose/moxmybike/ui/bikes/BikesScreen.kt&quot;,&quot;code_text&quot;:&quot;package com.moxmose.moxmybike.ui.bikes\r\n\r\nimport androidx.compose.foundation.ExperimentalFoundationApi\r\nimport androidx.compose.foundation.gestures.detectDragGesturesAfterLongPress\r\nimport androidx.compose.foundation.gestures.scrollBy\r\nimport androidx.compose.foundation.layout.Arrangement\r\nimport androidx.compose.foundation.layout.Box\r\nimport androidx.compose.foundation.layout.Row\r\nimport androidx.compose.foundation.layout.fillMaxSize\r\nimport androidx.compose.foundation.layout.fillMaxWidth\r\nimport androidx.compose.foundation.layout.padding\r\nimport androidx.compose.foundation.lazy.LazyColumn\r\nimport androidx.compose.foundation.lazy.LazyItemScope\r\nimport androidx.compose.foundation.lazy.LazyListItemInfo\r\nimport androidx.compose.foundation.lazy.LazyListState\r\nimport androidx.compose.foundation.lazy.itemsIndexed\r\nimport androidx.compose.foundation.lazy.rememberLazyListState\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.filled.Add\r\nimport androidx.compose.material.icons.filled.Done\r\nimport androidx.compose.material.icons.filled.Edit\r\nimport androidx.compose.material3.AlertDialog\r\nimport androidx.compose.material3.Card\r\nimport androidx.compose.material3.ExperimentalMaterial3Api\r\nimport androidx.compose.material3.FloatingActionButton\r\nimport androidx.compose.material3.Icon\r\nimport androidx.compose.material3.IconButton\r\nimport androidx.compose.material3.OutlinedTextField\r\nimport androidx.compose.material3.Scaffold\r\nimport androidx.compose.material3.Text\r\nimport androidx.compose.material3.TextButton\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.runtime.LaunchedEffect\r\nimport androidx.compose.runtime.State\r\nimport androidx.compose.runtime.collectAsState\r\nimport androidx.compose.runtime.derivedStateOf\r\nimport androidx.compose.runtime.getValue\r\nimport androidx.compose.runtime.mutableStateOf\r\nimport androidx.compose.runtime.remember\r\nimport androidx.compose.runtime.rememberCoroutineScope\r\nimport androidx.compose.runtime.setValue\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.geometry.Offset\r\nimport androidx.compose.ui.graphics.graphicsLayer\r\nimport androidx.compose.ui.input.pointer.pointerInput\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.compose.ui.zIndex\r\nimport com.moxmose.moxmybike.data.local.Bike\r\nimport kotlinx.coroutines.Job\r\nimport kotlinx.coroutines.launch\r\nimport org.koin.androidx.compose.koinViewModel\r\n\r\n@OptIn(ExperimentalMaterial3Api::class)\r\n@Composable\r\nfun BikesScreen(viewModel: BikesViewModel \u003d koinViewModel()) {\r\n    val bikesFromDb by viewModel.allBikes.collectAsState()\r\n    var showDialog by remember { mutableStateOf(false) }\r\n\r\n    var bikes by remember { mutableStateOf\u003cList\u003cBike\u003e\u003e(emptyList()) }\r\n    LaunchedEffect(bikesFromDb) {\r\n        bikes \u003d bikesFromDb\r\n    }\r\n\r\n    Scaffold(\r\n        floatingActionButton \u003d {\r\n            FloatingActionButton(onClick \u003d { showDialog \u003d true }) {\r\n                Icon(Icons.Filled.Add, contentDescription \u003d \&quot;Add Bike\&quot;)\r\n            }\r\n        }\r\n    ) { paddingValues -\u003e\r\n        if (showDialog) {\r\n            AddBikeDialog(\r\n                onDismissRequest \u003d { showDialog \u003d false },\r\n                onConfirm \u003d { description -\u003e\r\n                    viewModel.addBike(description)\r\n                    showDialog \u003d false\r\n                }\r\n            )\r\n        }\r\n\r\n        DraggableLazyColumn(\r\n            items \u003d bikes,\r\n            key \u003d { _, bike -\u003e bike.id },\r\n            onMove \u003d { from, to -\u003e\r\n                bikes \u003d bikes.toMutableList().apply {\r\n                    add(to, removeAt(from))\r\n                }\r\n            },\r\n            onDrop \u003d {\r\n                val reorderedBikes \u003d bikes.mapIndexed { index, bike -\u003e\r\n                    bike.copy(displayOrder \u003d index)\r\n                }\r\n                viewModel.updateBikes(reorderedBikes)\r\n            },\r\n            modifier \u003d Modifier.padding(paddingValues).fillMaxSize(),\r\n            itemContent \u003d { _, bike -\u003e\r\n                BikeCard(\r\n                    bike \u003d bike,\r\n                    viewModel \u003d viewModel\r\n                )\r\n            }\r\n        )\r\n    }\r\n}\r\n\r\n@OptIn(ExperimentalFoundationApi::class)\r\n@Composable\r\nprivate fun \u003cT : Any\u003e DraggableLazyColumn(\r\n    modifier: Modifier \u003d Modifier,\r\n    items: List\u003cT\u003e,\r\n    key: (index: Int, item: T) -\u003e Any,\r\n    onMove: (from: Int, to: Int) -\u003e Unit,\r\n    onDrop: () -\u003e Unit,\r\n    itemContent: @Composable LazyItemScope.(index: Int, item: T) -\u003e Unit,\r\n) {\r\n    val scope \u003d rememberCoroutineScope()\r\n    val lazyListState \u003d rememberLazyListState()\r\n    var overscrollJob by remember { mutableStateOf\u003cJob?\u003e(null) }\r\n\r\n    val dragDropState \u003d remember { DragDropState(onMove \u003d onMove, onDrop \u003d onDrop) }\r\n\r\n    LazyColumn(\r\n        modifier \u003d modifier.pointerInput(Unit) {\r\n            detectDragGesturesAfterLongPress(\r\n                onDrag \u003d { change, dragAmount -\u003e\r\n                    change.consume()\r\n                    dragDropState.onDrag(dragAmount, lazyListState)\r\n\r\n                    if (overscrollJob?.isActive !\u003d true) {\r\n                        val overscroll \u003d dragDropState.checkForOverscroll(lazyListState)\r\n                        if (overscroll !\u003d 0f) {\r\n                            overscrollJob \u003d scope.launch {\r\n                                lazyListState.scrollBy(overscroll)\r\n                            }\r\n                        } else {\r\n                            overscrollJob?.cancel()\r\n                        }\r\n                    }\r\n                },\r\n                onDragStart \u003d { offset -\u003e dragDropState.onDragStart(offset, lazyListState) },\r\n                onDragEnd \u003d { dragDropState.onDragEnd() },\r\n                onDragCancel \u003d { dragDropState.onDragEnd() }\r\n            )\r\n        },\r\n        state \u003d lazyListState\r\n    ) {\r\n        itemsIndexed(items, key) { index, item -\u003e\r\n            val currentKey \u003d key(index, item)\r\n            val isDragging \u003d dragDropState.isDragging(currentKey)\r\n            val offset by dragDropState.offsetOf(currentKey)\r\n\r\n            Box(\r\n                modifier \u003d Modifier\r\n                    .zIndex(if (isDragging) 1f else 0f)\r\n                    .graphicsLayer { translationY \u003d offset }\r\n            ) {\r\n                itemContent(index, item)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nprivate class DragDropState(\r\n    private val onMove: (from: Int, to: Int) -\u003e Unit,\r\n    private val onDrop: () -\u003e Unit\r\n) {\r\n    var draggedDistance by mutableStateOf(0f)\r\n        private set\r\n    var draggedItemKey by mutableStateOf\u003cAny?\u003e(null)\r\n        private set\r\n\r\n    private var currentIndexOfDraggedItem by mutableStateOf\u003cInt?\u003e(null)\r\n    private var initiallyDraggedElement by mutableStateOf\u003cLazyListItemInfo?\u003e(null)\r\n\r\n    fun isDragging(itemKey: Any): Boolean \u003d itemKey \u003d\u003d draggedItemKey\r\n\r\n    fun offsetOf(itemKey: Any): State\u003cFloat\u003e \u003d derivedStateOf {\r\n        if (itemKey \u003d\u003d draggedItemKey) {\r\n            draggedDistance\r\n        } else {\r\n            0f\r\n        }\r\n    }\r\n\r\n    fun onDragStart(offset: Offset, lazyListState: LazyListState) {\r\n        lazyListState.layoutInfo.visibleItemsInfo\r\n            .firstOrNull { offset.y.toInt() in it.offset..(it.offset + it.size) }\r\n            ?.also {\r\n                currentIndexOfDraggedItem \u003d it.index\r\n                initiallyDraggedElement \u003d it\r\n                draggedItemKey \u003d it.key\r\n            }\r\n    }\r\n\r\n    fun onDrag(dragAmount: Offset, lazyListState: LazyListState) {\r\n        draggedDistance +\u003d dragAmount.y\r\n        val initial \u003d initiallyDraggedElement ?: return\r\n        val currentDraggedIndex \u003d currentIndexOfDraggedItem ?: return\r\n\r\n        val currentOffset \u003d initial.offset + draggedDistance\r\n\r\n        val layoutInfo \u003d lazyListState.layoutInfo\r\n        val visibleItemsMap \u003d layoutInfo.visibleItemsInfo.associateBy { it.index }\r\n\r\n        val targetItem \u003d when {\r\n            dragAmount.y \u003e 0 -\u003e (currentDraggedIndex + 1 until layoutInfo.totalItemsCount)\r\n                .asSequence()\r\n                .mapNotNull { visibleItemsMap[it] }\r\n                .firstOrNull { item -\u003e currentOffset + initial.size \u003e item.offset + item.size/2 }\r\n//                .firstOrNull { item -\u003e currentOffset + initial.size \u003e item.offset + item.size / 2 }\r\n\r\n            dragAmount.y \u003c 0 -\u003e (0 until currentDraggedIndex).reversed()\r\n                .asSequence()\r\n                .mapNotNull { visibleItemsMap[it] }\r\n                .firstOrNull { item -\u003e currentOffset \u003c item.offset + item.size / 2 }\r\n\r\n            else -\u003e null\r\n        }\r\n\r\n        if (targetItem !\u003d null) {\r\n            val from \u003d currentDraggedIndex\r\n            val to \u003d targetItem.index\r\n            if (from !\u003d to) {\r\n                onMove(from, to)\r\n                draggedDistance +\u003d if (from \u003c to) -targetItem.size else targetItem.size\r\n                currentIndexOfDraggedItem \u003d to\r\n            }\r\n        }\r\n    }\r\n\r\n    fun onDragEnd() {\r\n        onDrop()\r\n        reset()\r\n    }\r\n\r\n    fun checkForOverscroll(lazyListState: LazyListState): Float {\r\n        val initial \u003d initiallyDraggedElement ?: return 0f\r\n        val startOffset \u003d initial.offset + draggedDistance\r\n        val endOffset \u003d initial.offset + initial.size + draggedDistance\r\n\r\n        return when {\r\n            draggedDistance \u003e 0 \u0026\u0026 endOffset \u003e lazyListState.layoutInfo.viewportEndOffset -\u003e draggedDistance * 0.05f\r\n            draggedDistance \u003c 0 \u0026\u0026 startOffset \u003c lazyListState.layoutInfo.viewportStartOffset -\u003e draggedDistance * 0.05f\r\n            else -\u003e 0f\r\n        }\r\n    }\r\n\r\n    private fun reset() {\r\n        draggedDistance \u003d 0f\r\n        initiallyDraggedElement \u003d null\r\n        currentIndexOfDraggedItem \u003d null\r\n        draggedItemKey \u003d null\r\n    }\r\n}\r\n\r\n@Composable\r\nfun AddBikeDialog(onDismissRequest: () -\u003e Unit, onConfirm: (String) -\u003e Unit) {\r\n    var description by remember { mutableStateOf(\&quot;\&quot;) }\r\n\r\n    AlertDialog(\r\n        onDismissRequest \u003d onDismissRequest,\r\n        title \u003d { Text(\&quot;Add a new bike\&quot;) },\r\n        text \u003d {\r\n            OutlinedTextField(\r\n                value \u003d description,\r\n                onValueChange \u003d { description \u003d it },\r\n                label \u003d { Text(\&quot;Bike description\&quot;) },\r\n                singleLine \u003d true\r\n            )\r\n        },\r\n        confirmButton \u003d {\r\n            TextButton(\r\n                onClick \u003d {\r\n                    if (description.isNotBlank()) {\r\n                        onConfirm(description)\r\n                    }\r\n                }\r\n            ) {\r\n                Text(\&quot;Add\&quot;)\r\n            }\r\n        },\r\n        dismissButton \u003d {\r\n            TextButton(onClick \u003d onDismissRequest) {\r\n                Text(\&quot;Cancel\&quot;)\r\n            }\r\n        }\r\n    )\r\n}\r\n\r\n@Composable\r\nfun BikeCard(bike: Bike, viewModel: BikesViewModel, modifier: Modifier \u003d Modifier) {\r\n    var isEditing by remember { mutableStateOf(false) }\r\n    var editedDescription by remember { mutableStateOf(bike.description) }\r\n\r\n    LaunchedEffect(bike.description) {\r\n        if (!isEditing) {\r\n            editedDescription \u003d bike.description\r\n        }\r\n    }\r\n\r\n    Card(\r\n        modifier \u003d modifier\r\n            .padding(8.dp)\r\n            .fillMaxWidth()\r\n    ) {\r\n        Row(\r\n            modifier \u003d Modifier.padding(horizontal \u003d 16.dp, vertical \u003d 8.dp),\r\n            verticalAlignment \u003d Alignment.CenterVertically,\r\n            horizontalArrangement \u003d Arrangement.SpaceBetween\r\n        ) {\r\n            if (isEditing) {\r\n                OutlinedTextField(\r\n                    value \u003d editedDescription,\r\n                    onValueChange \u003d { editedDescription \u003d it },\r\n                    label \u003d { Text(\&quot;Bike Description\&quot;) },\r\n                    modifier \u003d Modifier.weight(1f)\r\n                )\r\n            } else {\r\n                Text(\r\n                    text \u003d bike.description,\r\n                    modifier \u003d Modifier.weight(1f)\r\n                )\r\n            }\r\n            IconButton(\r\n                onClick \u003d {\r\n                    if (isEditing) {\r\n                        viewModel.updateBike(bike.copy(description \u003d editedDescription))\r\n                    }\r\n                    isEditing \u003d !isEditing\r\n                }\r\n            ) {\r\n                Icon(\r\n                    imageVector \u003d if (isEditing) Icons.Filled.Done else Icons.Filled.Edit,\r\n                    contentDescription \u003d if (isEditing) \&quot;Save\&quot; else \&quot;Edit Bike\&quot;\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n&quot;,&quot;ranges&quot;:[],&quot;type&quot;:&quot;current_file&quot;},{&quot;mode&quot;:&quot;Write&quot;,&quot;plan_file_path&quot;:&quot;C:\\Users\\Utente\\.firebender\\projects\\C:-Users-Utente-AndroidStudioProjects-Mox_My_Bike\\plans\\plan-1a2ce0.md&quot;,&quot;ranges&quot;:[],&quot;type&quot;:&quot;query_metadata&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[]}]},&quot;90b22fcc-bf74-4897-a793-fbca186b3fde&quot;:{&quot;id&quot;:&quot;90b22fcc-bf74-4897-a793-fbca186b3fde&quot;,&quot;name&quot;:&quot;Inizio dello swap delle card in BikeScreen.kt durante lo sfioramento&quot;,&quot;timestamp&quot;:1766074652645,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Voglio sapere una cosa: su BikeScreen.kt c\u0027è una proprietà che mi permetta di gestire l\u0027inizio dello swap delle card quando le card si \&quot;sfiorano\&quot; ancora prima di sovrapporsi, quindi quando la prima card si è mossa solo dello spacing tra le card (se la card ha un padding di zero ed uno spacer esterno)?&quot;}],&quot;context&quot;:[{&quot;file_path&quot;:&quot;app/src/main/java/com/moxmose/moxmybike/ui/bikes/BikesScreen.kt&quot;,&quot;code_text&quot;:&quot;package com.moxmose.moxmybike.ui.bikes\r\n\r\nimport androidx.compose.foundation.ExperimentalFoundationApi\r\nimport androidx.compose.foundation.gestures.detectDragGesturesAfterLongPress\r\nimport androidx.compose.foundation.gestures.scrollBy\r\nimport androidx.compose.foundation.layout.Arrangement\r\nimport androidx.compose.foundation.layout.Box\r\nimport androidx.compose.foundation.layout.Row\r\nimport androidx.compose.foundation.layout.fillMaxSize\r\nimport androidx.compose.foundation.layout.fillMaxWidth\r\nimport androidx.compose.foundation.layout.padding\r\nimport androidx.compose.foundation.lazy.LazyColumn\r\nimport androidx.compose.foundation.lazy.LazyItemScope\r\nimport androidx.compose.foundation.lazy.LazyListItemInfo\r\nimport androidx.compose.foundation.lazy.LazyListState\r\nimport androidx.compose.foundation.lazy.itemsIndexed\r\nimport androidx.compose.foundation.lazy.rememberLazyListState\r\nimport androidx.compose.material.icons.Icons\r\nimport androidx.compose.material.icons.filled.Add\r\nimport androidx.compose.material.icons.filled.Done\r\nimport androidx.compose.material.icons.filled.Edit\r\nimport androidx.compose.material3.AlertDialog\r\nimport androidx.compose.material3.Card\r\nimport androidx.compose.material3.ExperimentalMaterial3Api\r\nimport androidx.compose.material3.FloatingActionButton\r\nimport androidx.compose.material3.Icon\r\nimport androidx.compose.material3.IconButton\r\nimport androidx.compose.material3.OutlinedTextField\r\nimport androidx.compose.material3.Scaffold\r\nimport androidx.compose.material3.Text\r\nimport androidx.compose.material3.TextButton\r\nimport androidx.compose.runtime.Composable\r\nimport androidx.compose.runtime.LaunchedEffect\r\nimport androidx.compose.runtime.State\r\nimport androidx.compose.runtime.collectAsState\r\nimport androidx.compose.runtime.derivedStateOf\r\nimport androidx.compose.runtime.getValue\r\nimport androidx.compose.runtime.mutableStateOf\r\nimport androidx.compose.runtime.remember\r\nimport androidx.compose.runtime.rememberCoroutineScope\r\nimport androidx.compose.runtime.setValue\r\nimport androidx.compose.ui.Alignment\r\nimport androidx.compose.ui.Modifier\r\nimport androidx.compose.ui.geometry.Offset\r\nimport androidx.compose.ui.graphics.graphicsLayer\r\nimport androidx.compose.ui.input.pointer.pointerInput\r\nimport androidx.compose.ui.unit.dp\r\nimport androidx.compose.ui.zIndex\r\nimport com.moxmose.moxmybike.data.local.Bike\r\nimport kotlinx.coroutines.Job\r\nimport kotlinx.coroutines.launch\r\nimport org.koin.androidx.compose.koinViewModel\r\n\r\n@OptIn(ExperimentalMaterial3Api::class)\r\n@Composable\r\nfun BikesScreen(viewModel: BikesViewModel \u003d koinViewModel()) {\r\n    val bikesFromDb by viewModel.allBikes.collectAsState()\r\n    var showDialog by remember { mutableStateOf(false) }\r\n\r\n    var bikes by remember { mutableStateOf\u003cList\u003cBike\u003e\u003e(emptyList()) }\r\n    LaunchedEffect(bikesFromDb) {\r\n        bikes \u003d bikesFromDb\r\n    }\r\n\r\n    Scaffold(\r\n        floatingActionButton \u003d {\r\n            FloatingActionButton(onClick \u003d { showDialog \u003d true }) {\r\n                Icon(Icons.Filled.Add, contentDescription \u003d \&quot;Add Bike\&quot;)\r\n            }\r\n        }\r\n    ) { paddingValues -\u003e\r\n        if (showDialog) {\r\n            AddBikeDialog(\r\n                onDismissRequest \u003d { showDialog \u003d false },\r\n                onConfirm \u003d { description -\u003e\r\n                    viewModel.addBike(description)\r\n                    showDialog \u003d false\r\n                }\r\n            )\r\n        }\r\n\r\n        DraggableLazyColumn(\r\n            items \u003d bikes,\r\n            key \u003d { _, bike -\u003e bike.id },\r\n            onMove \u003d { from, to -\u003e\r\n                bikes \u003d bikes.toMutableList().apply {\r\n                    add(to, removeAt(from))\r\n                }\r\n            },\r\n            onDrop \u003d {\r\n                val reorderedBikes \u003d bikes.mapIndexed { index, bike -\u003e\r\n                    bike.copy(displayOrder \u003d index)\r\n                }\r\n                viewModel.updateBikes(reorderedBikes)\r\n            },\r\n            modifier \u003d Modifier.padding(paddingValues).fillMaxSize(),\r\n            itemContent \u003d { _, bike -\u003e\r\n                BikeCard(\r\n                    bike \u003d bike,\r\n                    viewModel \u003d viewModel\r\n                )\r\n            }\r\n        )\r\n    }\r\n}\r\n\r\n@OptIn(ExperimentalFoundationApi::class)\r\n@Composable\r\nprivate fun \u003cT : Any\u003e DraggableLazyColumn(\r\n    modifier: Modifier \u003d Modifier,\r\n    items: List\u003cT\u003e,\r\n    key: (index: Int, item: T) -\u003e Any,\r\n    onMove: (from: Int, to: Int) -\u003e Unit,\r\n    onDrop: () -\u003e Unit,\r\n    itemContent: @Composable LazyItemScope.(index: Int, item: T) -\u003e Unit,\r\n) {\r\n    val scope \u003d rememberCoroutineScope()\r\n    val lazyListState \u003d rememberLazyListState()\r\n    var overscrollJob by remember { mutableStateOf\u003cJob?\u003e(null) }\r\n\r\n    val dragDropState \u003d remember { DragDropState(onMove \u003d onMove, onDrop \u003d onDrop) }\r\n\r\n    LazyColumn(\r\n        modifier \u003d modifier.pointerInput(Unit) {\r\n            detectDragGesturesAfterLongPress(\r\n                onDrag \u003d { change, dragAmount -\u003e\r\n                    change.consume()\r\n                    dragDropState.onDrag(dragAmount, lazyListState)\r\n\r\n                    if (overscrollJob?.isActive !\u003d true) {\r\n                        val overscroll \u003d dragDropState.checkForOverscroll(lazyListState)\r\n                        if (overscroll !\u003d 0f) {\r\n                            overscrollJob \u003d scope.launch {\r\n                                lazyListState.scrollBy(overscroll)\r\n                            }\r\n                        } else {\r\n                            overscrollJob?.cancel()\r\n                        }\r\n                    }\r\n                },\r\n                onDragStart \u003d { offset -\u003e dragDropState.onDragStart(offset, lazyListState) },\r\n                onDragEnd \u003d { dragDropState.onDragEnd() },\r\n                onDragCancel \u003d { dragDropState.onDragEnd() }\r\n            )\r\n        },\r\n        state \u003d lazyListState\r\n    ) {\r\n        itemsIndexed(items, key) { index, item -\u003e\r\n            val currentKey \u003d key(index, item)\r\n            val isDragging \u003d dragDropState.isDragging(currentKey)\r\n            val offset by dragDropState.offsetOf(currentKey)\r\n\r\n            Box(\r\n                modifier \u003d Modifier\r\n                    .zIndex(if (isDragging) 1f else 0f)\r\n                    .graphicsLayer { translationY \u003d offset }\r\n            ) {\r\n                itemContent(index, item)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nprivate class DragDropState(\r\n    private val onMove: (from: Int, to: Int) -\u003e Unit,\r\n    private val onDrop: () -\u003e Unit\r\n) {\r\n    var draggedDistance by mutableStateOf(0f)\r\n        private set\r\n    var draggedItemKey by mutableStateOf\u003cAny?\u003e(null)\r\n        private set\r\n\r\n    private var currentIndexOfDraggedItem by mutableStateOf\u003cInt?\u003e(null)\r\n    private var initiallyDraggedElement by mutableStateOf\u003cLazyListItemInfo?\u003e(null)\r\n\r\n    fun isDragging(itemKey: Any): Boolean \u003d itemKey \u003d\u003d draggedItemKey\r\n\r\n    fun offsetOf(itemKey: Any): State\u003cFloat\u003e \u003d derivedStateOf {\r\n        if (itemKey \u003d\u003d draggedItemKey) {\r\n            draggedDistance\r\n        } else {\r\n            0f\r\n        }\r\n    }\r\n\r\n    fun onDragStart(offset: Offset, lazyListState: LazyListState) {\r\n        lazyListState.layoutInfo.visibleItemsInfo\r\n            .firstOrNull { offset.y.toInt() in it.offset..(it.offset + it.size) }\r\n            ?.also {\r\n                currentIndexOfDraggedItem \u003d it.index\r\n                initiallyDraggedElement \u003d it\r\n                draggedItemKey \u003d it.key\r\n            }\r\n    }\r\n\r\n    fun onDrag(dragAmount: Offset, lazyListState: LazyListState) {\r\n        draggedDistance +\u003d dragAmount.y\r\n        val initial \u003d initiallyDraggedElement ?: return\r\n        val currentDraggedIndex \u003d currentIndexOfDraggedItem ?: return\r\n\r\n        val currentOffset \u003d initial.offset + draggedDistance\r\n\r\n        val layoutInfo \u003d lazyListState.layoutInfo\r\n        val visibleItemsMap \u003d layoutInfo.visibleItemsInfo.associateBy { it.index }\r\n\r\n        val targetItem \u003d when {\r\n            dragAmount.y \u003e 0 -\u003e (currentDraggedIndex + 1 until layoutInfo.totalItemsCount)\r\n                .asSequence()\r\n                .mapNotNull { visibleItemsMap[it] }\r\n                .firstOrNull { item -\u003e currentOffset + initial.size \u003e item.offset + item.size/2 }\r\n//                .firstOrNull { item -\u003e currentOffset + initial.size \u003e item.offset + item.size / 2 }\r\n\r\n            dragAmount.y \u003c 0 -\u003e (0 until currentDraggedIndex).reversed()\r\n                .asSequence()\r\n                .mapNotNull { visibleItemsMap[it] }\r\n                .firstOrNull { item -\u003e currentOffset \u003c item.offset + item.size / 2 }\r\n\r\n            else -\u003e null\r\n        }\r\n\r\n        if (targetItem !\u003d null) {\r\n            val from \u003d currentDraggedIndex\r\n            val to \u003d targetItem.index\r\n            if (from !\u003d to) {\r\n                onMove(from, to)\r\n                draggedDistance +\u003d if (from \u003c to) -targetItem.size else targetItem.size\r\n                currentIndexOfDraggedItem \u003d to\r\n            }\r\n        }\r\n    }\r\n\r\n    fun onDragEnd() {\r\n        onDrop()\r\n        reset()\r\n    }\r\n\r\n    fun checkForOverscroll(lazyListState: LazyListState): Float {\r\n        val initial \u003d initiallyDraggedElement ?: return 0f\r\n        val startOffset \u003d initial.offset + draggedDistance\r\n        val endOffset \u003d initial.offset + initial.size + draggedDistance\r\n\r\n        return when {\r\n            draggedDistance \u003e 0 \u0026\u0026 endOffset \u003e lazyListState.layoutInfo.viewportEndOffset -\u003e draggedDistance * 0.05f\r\n            draggedDistance \u003c 0 \u0026\u0026 startOffset \u003c lazyListState.layoutInfo.viewportStartOffset -\u003e draggedDistance * 0.05f\r\n            else -\u003e 0f\r\n        }\r\n    }\r\n\r\n    private fun reset() {\r\n        draggedDistance \u003d 0f\r\n        initiallyDraggedElement \u003d null\r\n        currentIndexOfDraggedItem \u003d null\r\n        draggedItemKey \u003d null\r\n    }\r\n}\r\n\r\n@Composable\r\nfun AddBikeDialog(onDismissRequest: () -\u003e Unit, onConfirm: (String) -\u003e Unit) {\r\n    var description by remember { mutableStateOf(\&quot;\&quot;) }\r\n\r\n    AlertDialog(\r\n        onDismissRequest \u003d onDismissRequest,\r\n        title \u003d { Text(\&quot;Add a new bike\&quot;) },\r\n        text \u003d {\r\n            OutlinedTextField(\r\n                value \u003d description,\r\n                onValueChange \u003d { description \u003d it },\r\n                label \u003d { Text(\&quot;Bike description\&quot;) },\r\n                singleLine \u003d true\r\n            )\r\n        },\r\n        confirmButton \u003d {\r\n            TextButton(\r\n                onClick \u003d {\r\n                    if (description.isNotBlank()) {\r\n                        onConfirm(description)\r\n                    }\r\n                }\r\n            ) {\r\n                Text(\&quot;Add\&quot;)\r\n            }\r\n        },\r\n        dismissButton \u003d {\r\n            TextButton(onClick \u003d onDismissRequest) {\r\n                Text(\&quot;Cancel\&quot;)\r\n            }\r\n        }\r\n    )\r\n}\r\n\r\n@Composable\r\nfun BikeCard(bike: Bike, viewModel: BikesViewModel, modifier: Modifier \u003d Modifier) {\r\n    var isEditing by remember { mutableStateOf(false) }\r\n    var editedDescription by remember { mutableStateOf(bike.description) }\r\n\r\n    LaunchedEffect(bike.description) {\r\n        if (!isEditing) {\r\n            editedDescription \u003d bike.description\r\n        }\r\n    }\r\n\r\n    Card(\r\n        modifier \u003d modifier\r\n            .padding(8.dp)\r\n            .fillMaxWidth()\r\n    ) {\r\n        Row(\r\n            modifier \u003d Modifier.padding(horizontal \u003d 16.dp, vertical \u003d 8.dp),\r\n            verticalAlignment \u003d Alignment.CenterVertically,\r\n            horizontalArrangement \u003d Arrangement.SpaceBetween\r\n        ) {\r\n            if (isEditing) {\r\n                OutlinedTextField(\r\n                    value \u003d editedDescription,\r\n                    onValueChange \u003d { editedDescription \u003d it },\r\n                    label \u003d { Text(\&quot;Bike Description\&quot;) },\r\n                    modifier \u003d Modifier.weight(1f)\r\n                )\r\n            } else {\r\n                Text(\r\n                    text \u003d bike.description,\r\n                    modifier \u003d Modifier.weight(1f)\r\n                )\r\n            }\r\n            IconButton(\r\n                onClick \u003d {\r\n                    if (isEditing) {\r\n                        viewModel.updateBike(bike.copy(description \u003d editedDescription))\r\n                    }\r\n                    isEditing \u003d !isEditing\r\n                }\r\n            ) {\r\n                Icon(\r\n                    imageVector \u003d if (isEditing) Icons.Filled.Done else Icons.Filled.Edit,\r\n                    contentDescription \u003d if (isEditing) \&quot;Save\&quot; else \&quot;Edit Bike\&quot;\r\n                )\r\n            }\r\n        }\r\n    }\r\n}\r\n&quot;,&quot;ranges&quot;:[],&quot;type&quot;:&quot;current_file&quot;},{&quot;mode&quot;:&quot;Write&quot;,&quot;plan_file_path&quot;:&quot;C:\\Users\\Utente\\.firebender\\projects\\C:-Users-Utente-AndroidStudioProjects-Mox_My_Bike\\plans\\plan-a3de6e.md&quot;,&quot;ranges&quot;:[],&quot;type&quot;:&quot;query_metadata&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[]}]}}" />
  </component>
</project>